0.立即数：就是常数12345什么的，
		二进制后面跟B：0101B
		十进制后面不跟：105
		十六进制后面跟H：0FFH  注意如果16进制都是字母的话，前面要跟一个0表示是个数字（不然编译器会认为这是个变量，开头不能是字母）
	数组定义：(标号，变量名)
	标号+数据类型+数据 ,d(define)，b（byte）w(word，x8086是16位两字节，和计算机位长)，d（double四字节）
	标号后面没有冒号，本质是地址，
	如:	co db 2 (定义一个变量co，一字节，值为2)
		co db 1,2,3,4,4	(定义数组)
[] bx， 立即数， si， di
定义数组  a dw [0]=5  [1] = 5的高位
联系定义申请   
批量：	标号名+数据类型+个数+dup(初值)
	如：	co db 10 dup(0) 定义一个数组co[10]，值为全0
8086 段结构
1mb = 2^20 
地址 ==（段+偏移地址）
1.段（只能用寄存器访问）

	DS：数据段，跟数据有关的指针、数组寻址、默认DS
	SS：栈段，SP（栈顶指针），BP（栈操作指针）（操作：push pop）
	CS:指令段，跟IP结合，（只能用转移指令，不能手动修改）不用管。
2.寻址（考虑段）
	DS 只能寄存器传递
	mov AX, DATA
	mov DS, AX
	CS 跳转语句传递
BYTE PTR [BX] ;按字节访问
WORD PTR [BX] ;按字访问
Emu8086 容许使用如下更简洁的前缀
b. - 等价于上面的 BYTE PTR
w. - 等价于上面的 WORD PTR		（我没用过这两种前缀）

	[立即数地址]		;不建议
	[bx]			;汇编中中括号里只能出现BX（BL，BH），DI，SI，立即数
	[bx][si+立即数]		;不建议使用
	等价于[bx+si+立即数]	;
	co[0]			;位长是1字节，跟定义没关系，所以要自己计算偏移量
	co[bx]、co[bx+立即数]
	co[bx+si+立即数]    
	等价于co[bx+0][si+0]	;不建议使用
	co[bx+si*4]		;*号一边必须是立即数
	;汇编没有二维数组的概念，只能自己计算偏移量

[BX+DI*2]  ==BX[DI*2]
3.中断
int 21H(调用系统函数)

4.跳转 j(jmp的意思)，a（above大于），b(below小于)，e(equal等于)，n（not反逻辑）
	如jne表示如果不等于就跳，ja表示大于就跳

jmp+标号  （变量名==地址）
带条件转移  je
标志位：flag寄存器，sub==减，（zf，of，cf，判断大小）
cmp 不修改结果，只保存标志位
loop 与CS寄存器搭配（inc加一命令，dec减一）

5.push、pop  SP和SS决定了栈位置，BP可以用来随机访问栈空间
6.pushf、flag标志位
7.函数调用 call（标号，函数名）、ret（从栈里取出地址，再挑回来） 找sp对应的地址	

8.其他常用命令：
	EQU伪指令	复杂的宏定义我们不用，这是简单的定义常量： ABC EQU 12 相当于#define ABC 12
	mov 两个之间必须有一个是寄存器（操作位数由寄存器决定）
	jmp系列，跳转
	loop
	add ax,bx 	;ax+=bx	影响标志位
	sub ax,bx	;ax-=bx	影响标志位
	inc ax		;ax++	不影响标志位
	dec ax		;ax--	不影响标志位
	offset伪指令	;取地址，如 mov bx,offset co，取co的地址。
	
	;div 除法： 被除数: 如果除数是8位则被除数为16位, 默认放在AX中, 如果除数是16位, 则被除数为32位, 默认高位放在DX, 低位放在AX。结果: 如果除数是8位, 那么执行div后, 余数存放在ah, 商存放在AL中; 如果除数是16位, 那么AX保存商, DX保存余数 
	
	mul （我没用过）乘法 https://blog.csdn.net/best_fiends_zxh/article/details/52727797

传参，返回
布尔值， sub ax，ax  ；jz，jnz  真zf=1，约定ax为返回值
参数用ax传参
ax和bp不能在主函数用
若是bool型的返回值设置zf，其他返回值使用ax。参数使用ax,bx,若不够直接使用栈（就不用ax和bx了）
主函数正向子程序逆向取
ax能当做返回值

命令规范：
函数不能重名

	