 
1. 写一个函数 求一个 string 中出现次数最多的单词 
```cpp
    string str("liu sheng xi  zui shuai  xi xi xi liu");
    istringstream line(str);
    string word, ret;
    //分离单词
    map<string, int> mp;
    int max = 0;
    while (cin >> word)
    {
        // if (mp.find(word) != mp.end())
        //     mp[word]++;
        // else
        //     mp.insert({word, 1});
        ++mp[word];
        if (mp[word] > max)
        {
            max = mp[word];
            ret = word;
        }
    }
    cout << ret << endl;
```

2. 实现基础函数

https://github.com/arkingc/note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93.md#2%E5%AE%9E%E7%8E%B0strcmp

while(*p++ = *strSrc++); //*p++等价于*(p++),先赋值再自增

3. 广搜去遍历树怎么遍历

给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。

例如:
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
            queue<TreeNode *> Que;
            TreeNode *it;
            vector<vector<int>> ret;
            if(!root)
                return ret;
            vector<int> tmp;
            Que.push(root);

            int k = 0;
            while (!Que.empty())
            {
                int len = Que.size();
                for (int i = 0; i < len; i++)
                {
                    it = Que.front();
                    tmp.push_back(it->val);
                    Que.pop();

                    if (it->left)
                        Que.push(it->left);
                    if (it->right)
                        Que.push(it->right);
                }
                ret.push_back(tmp);
                tmp.clear();
            }
        return ret;
        }
};
```